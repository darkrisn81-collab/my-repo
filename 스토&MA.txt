//+------------------------------------------------------------------+
//|                                Stochastic4StrategyEA.mq5         |
//|                   4가지 독립 전략 (양방향 포지션 가능)            |
//|                   v3.1 - 포지션 제한 및 시간대 필터 추가          |
//+------------------------------------------------------------------+
#property copyright "Copyright 2024"
#property version   "3.10"

#include <Trade\Trade.mqh>

//--- 입력 파라미터
input group "=== 기본 설정 ==="
input double   LotSize = 0.1;              // 거래 로트 크기
input int      MagicNumber_BuyBasic = 1001;    // 매수 기본 매직넘버
input int      MagicNumber_BuyTrend = 1002;    // 매수 추세 매직넘버
input int      MagicNumber_SellBasic = 2001;   // 매도 기본 매직넘버
input int      MagicNumber_SellTrend = 2002;   // 매도 추세 매직넘버

input group "=== Stochastic 설정 ==="
input int      Stoch_K = 23;               // %K 주기
input int      Stoch_D = 4;                // %D 주기
input int      Stoch_Slowing = 4;          // Slowing

input group "=== 상단 Moving Average 설정 ==="
input int      MA1_Period = 69;            // MA1 주기 (LWMA)
input int      MA2_Period = 60;            // MA2 주기 (SMA)
input int      MA3_Period = 23;            // MA3 주기 (LWMA) - 추세 전략용

input group "=== 하단 지표 설정 ==="
input int      StochMA_Period = 6;         // Stoch에 적용할 MA 주기
input int      BB_Period = 14;             // BB 주기
input double   BB_Deviation = 0.5;         // BB 편차

input group "=== 기준선 설정 ==="
input double   Level_Low = 20.0;           // 하단 기준선 (20)
input double   Level_BuyCancel = 40.0;     // 매수 대기 해제선 (40)
input double   Level_SellCancel = 60.0;    // 매도 대기 해제선 (60)
input double   Level_High = 80.0;          // 상단 기준선 (80)

input group "=== SL/TP 설정 ==="
input bool     UseSLTP = false;            // SL/TP 사용 여부
input int      StopLoss = 500;             // 손절 (포인트, 0=미사용)
input int      TakeProfit = 1000;          // 익절 (포인트, 0=미사용)

input group "=== SL 연속 손실 방지 ==="
input int      SL_CooldownMinutes = 10;    // SL 재발생 시 거래 정지 시간 (분)

input group "=== 추세 전략 SL 정지 ==="
input int      TrendSL_BlockMinutes = 20;  // 추세 전략 SL 2회 시 정지 시간 (분)

input group "=== 기본 전략 진입 대기 ==="
input int      BasicEntryWaitMinutes = 3;  // 신호 완성 후 진입 대기 시간 (분)

input group "=== 추세 전략 포지션 제한 ==="
input int      MaxTrendPositions = 3;      // 추세 전략 최대 포지션 수 (3~5 권장)
input int      TimeAttackMinutes = 8;      // 포지션 만료 시 강제 청산 시간 (분, 6~10 권장)

input group "=== 추세 전략 시간대 제한 (한국시간 기준) ==="
input bool     UseTrendTimeFilter = true;      // 추세 전략 시간 필터 사용
input int      Trend_Session1_Start = 8;       // 세션1 시작 (09:00)
input int      Trend_Session1_End = 12;        // 세션1 종료 (11:00)
input int      Trend_Session2_Start = 14;      // 세션2 시작 (14:00)
input int      Trend_Session2_End = 18;        // 세션2 종료 (18:00)
input int      Trend_Session3_Start = 20;      // 세션3 시작 (21:00)
input int      Trend_Session3_End = 24;        // 세션3 종료 (24:00)

//--- 전역 변수
CTrade trade;
int stochHandle;
int ma1Handle;
int ma2Handle;
int ma3Handle;

// 데이터 배열
double stochMain[];
double stochSignal[];
double ma1Values[];
double ma2Values[];
double ma3Values[];
double stochMA[];
double bbUpper[];
double bbMiddle[];
double bbLower[];

//--- 매수 기본 전략 상태
bool buyBasic_Waiting = false;
int buyBasic_CrossCount = 0;
bool buyBasic_Success1 = false;
bool buyBasic_Success2 = false;
bool buyBasic_ReadyToEnter = false;
datetime buyBasic_ReadyTime = 0;

//--- 매도 기본 전략 상태
bool sellBasic_Waiting = false;
int sellBasic_CrossCount = 0;
bool sellBasic_Success1 = false;
bool sellBasic_Success2 = false;
bool sellBasic_ReadyToEnter = false;
datetime sellBasic_ReadyTime = 0;

//--- 매수 추세 전략 상태
bool buyTrend_BelowMA23 = false;
datetime buyTrend_LastSL = 0;
int buyTrend_SLCount = 0;
bool buyTrend_Blocked = false;
datetime buyTrend_BlockUntil = 0;
datetime buyTrend_FirstPositionTime = 0;  // 첫 포지션 진입 시간
bool buyTrend_TimeAttackActive = false;   // 타임어택 활성화

//--- 매도 추세 전략 상태
bool sellTrend_AboveMA23 = false;
datetime sellTrend_LastSL = 0;
int sellTrend_SLCount = 0;
bool sellTrend_Blocked = false;
datetime sellTrend_BlockUntil = 0;
datetime sellTrend_FirstPositionTime = 0;
bool sellTrend_TimeAttackActive = false;

//--- SL 연속 손실 방지 시스템
datetime lastSLTime = 0;
bool tradingBlocked = false;
datetime blockUntilTime = 0;

//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   stochHandle = iStochastic(_Symbol, PERIOD_CURRENT, 
                            Stoch_K, Stoch_D, Stoch_Slowing,
                            MODE_LWMA, STO_LOWHIGH);
   
   ma1Handle = iMA(_Symbol, PERIOD_CURRENT, MA1_Period, 0, MODE_LWMA, PRICE_CLOSE);
   ma2Handle = iMA(_Symbol, PERIOD_CURRENT, MA2_Period, 0, MODE_SMA, PRICE_CLOSE);
   ma3Handle = iMA(_Symbol, PERIOD_CURRENT, MA3_Period, 0, MODE_LWMA, PRICE_CLOSE);
   
   if(stochHandle == INVALID_HANDLE || ma1Handle == INVALID_HANDLE || 
      ma2Handle == INVALID_HANDLE || ma3Handle == INVALID_HANDLE)
   {
      Print("지표 생성 실패");
      return(INIT_FAILED);
   }
   
   ArraySetAsSeries(stochMain, true);
   ArraySetAsSeries(stochSignal, true);
   ArraySetAsSeries(ma1Values, true);
   ArraySetAsSeries(ma2Values, true);
   ArraySetAsSeries(ma3Values, true);
   ArraySetAsSeries(stochMA, true);
   ArraySetAsSeries(bbUpper, true);
   ArraySetAsSeries(bbMiddle, true);
   ArraySetAsSeries(bbLower, true);
   
   Print("=== EA 초기화 완료 v3.1 ===");
   Print("전략: 4가지 독립 전략 (양방향 포지션 가능)");
   Print("추세 전략 최대 포지션: ", MaxTrendPositions);
   Print("타임어택: ", TimeAttackMinutes, "분");
      if(UseTrendTimeFilter)
      PrintFormat("추세 전략 시간대: %02d~%02d, %02d~%02d, %02d~%02d (한국시간)", 
                  Trend_Session1_Start, Trend_Session1_End,
                  Trend_Session2_Start, Trend_Session2_End,
                  Trend_Session3_Start, Trend_Session3_End);
   
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   IndicatorRelease(stochHandle);
   IndicatorRelease(ma1Handle);
   IndicatorRelease(ma2Handle);
   IndicatorRelease(ma3Handle);
   Print("EA 종료");
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   static datetime lastBarTime = 0;
   datetime currentBarTime = iTime(_Symbol, PERIOD_CURRENT, 0);
   
   if(currentBarTime == lastBarTime)
      return;
   lastBarTime = currentBarTime;
   
   if(!CopyIndicatorData()) return;
   CalculateStochMA();
   CalculateBBOnStoch();
   
   CheckSLEvents();
   UpdateTradingBlockStatus();
   UpdateTrendBlockStatus();
   
   // 타임어택 체크 및 강제 청산
   CheckTimeAttack();
   
   if(tradingBlocked)
      return;
   
   
   CheckBuyBasicStrategy();
   CheckBuyTrendStrategy();
   CheckSellBasicStrategy();
   CheckSellTrendStrategy();
}

//+------------------------------------------------------------------+
//| 지표 데이터 복사                                                  |
//+------------------------------------------------------------------+
bool CopyIndicatorData()
{
   if(CopyBuffer(stochHandle, 0, 0, 200, stochMain) < 200) return false;
   if(CopyBuffer(stochHandle, 1, 0, 200, stochSignal) < 200) return false;
   if(CopyBuffer(ma1Handle, 0, 0, 50, ma1Values) < 50) return false;
   if(CopyBuffer(ma2Handle, 0, 0, 50, ma2Values) < 50) return false;
   if(CopyBuffer(ma3Handle, 0, 0, 50, ma3Values) < 50) return false;
   return true;
}

//+------------------------------------------------------------------+
//| Stochastic에 MA 계산 (LWMA)                                       |
//+------------------------------------------------------------------+
void CalculateStochMA()
{
   ArrayResize(stochMA, ArraySize(stochMain));
   int size = ArraySize(stochMain);
   
   for(int i = 0; i < size; i++)
   {
      if (i + StochMA_Period >= size) break;
      double sum = 0, weightSum = 0;
      
      for(int j = 0; j < StochMA_Period; j++)
      {
         int weight = StochMA_Period - j;
         sum += stochMain[i + j] * weight;
         weightSum += weight;
      }
      stochMA[i] = sum / weightSum;
   }
}

//+------------------------------------------------------------------+
//| Bollinger Bands 계산                                             |
//+------------------------------------------------------------------+
void CalculateBBOnStoch()
{
   ArrayResize(bbUpper, ArraySize(stochMain));
   ArrayResize(bbMiddle, ArraySize(stochMain));
   ArrayResize(bbLower, ArraySize(stochMain));
   int size = ArraySize(stochMain);

   for(int i = 0; i < size; i++)
   {
      if (i + BB_Period >= size) break;
      
      double sum = 0;
      for(int j = 0; j < BB_Period; j++) 
         sum += stochMain[i + j];
      bbMiddle[i] = sum / BB_Period;
      
      double variance = 0;
      for(int j = 0; j < BB_Period; j++) 
         variance += MathPow(stochMain[i + j] - bbMiddle[i], 2);
      double stdDev = MathSqrt(variance / BB_Period);
      
      bbUpper[i] = bbMiddle[i] + (stdDev * BB_Deviation);
      bbLower[i] = bbMiddle[i] - (stdDev * BB_Deviation);
   }
}

//+------------------------------------------------------------------+
//| 한국 시간 가져오기 (UTC+9)                                        |
//+------------------------------------------------------------------+
datetime GetKoreaTime()
{
   return TimeCurrent() + (9 * 3600);
}

//+------------------------------------------------------------------+
//| 전체 거래 시간 체크                                               |
//+------------------------------------------------------------------+
bool IsGlobalTradingTime()
{
   MqlDateTime koreaTime;
   TimeToStruct(GetKoreaTime(), koreaTime);
   
   int currentHour = koreaTime.hour;
   
   return false;
}

//+------------------------------------------------------------------+
//| 추세 전략 거래 시간 체크                                          |
//+------------------------------------------------------------------+
bool IsTrendTradingTime()
{
   if(!UseTrendTimeFilter)
      return true;
   
   MqlDateTime koreaTime;
   TimeToStruct(GetKoreaTime(), koreaTime);
   
   int currentHour = koreaTime.hour;
   
   // 세션1: 09:00~11:00
   if(currentHour >= Trend_Session1_Start && currentHour < Trend_Session1_End)
      return true;
   
   // 세션2: 14:00~18:00
   if(currentHour >= Trend_Session2_Start && currentHour < Trend_Session2_End)
      return true;
   
   // 세션3: 21:00~24:00
   if(currentHour >= Trend_Session3_Start && currentHour < Trend_Session3_End)
      return true;
   
   return false;
}

//+------------------------------------------------------------------+
//| 추세 전략 오픈 포지션 수 카운트                                   |
//+------------------------------------------------------------------+
int CountTrendPositions(int magicNumber)
{
   int count = 0;
   
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol &&
            PositionGetInteger(POSITION_MAGIC) == magicNumber)
         {
            count++;
         }
      }
   }
   
   return count;
}

//+------------------------------------------------------------------+
//| 타임어택 체크 및 강제 청산                                        |
//+------------------------------------------------------------------+
void CheckTimeAttack()
{
   datetime currentTime = TimeCurrent();
   
   // 매수 추세 타임어택
   if(buyTrend_TimeAttackActive)
   {
      int elapsedMinutes = (int)((currentTime - buyTrend_FirstPositionTime) / 60);
      
      if(elapsedMinutes >= TimeAttackMinutes)
      {
         Print("=== 매수 추세: 타임어택 발동! 모든 포지션 청산 ===");
         CloseAllPositionsByMagic(MagicNumber_BuyTrend);
         buyTrend_TimeAttackActive = false;
         buyTrend_FirstPositionTime = 0;
      }
   }
   else
   {
      // 타임어택 활성화 체크
      int buyTrendCount = CountTrendPositions(MagicNumber_BuyTrend);
      if(buyTrendCount >= MaxTrendPositions && buyTrend_FirstPositionTime > 0)
      {
         buyTrend_TimeAttackActive = true;
         Print("=== 매수 추세: 최대 포지션 도달! 타임어택 시작 (", TimeAttackMinutes, "분) ===");
      }
   }
   
   // 매도 추세 타임어택
   if(sellTrend_TimeAttackActive)
   {
      int elapsedMinutes = (int)((currentTime - sellTrend_FirstPositionTime) / 60);
      
      if(elapsedMinutes >= TimeAttackMinutes)
      {
         Print("=== 매도 추세: 타임어택 발동! 모든 포지션 청산 ===");
         CloseAllPositionsByMagic(MagicNumber_SellTrend);
         sellTrend_TimeAttackActive = false;
         sellTrend_FirstPositionTime = 0;
      }
   }
   else
   {
      int sellTrendCount = CountTrendPositions(MagicNumber_SellTrend);
      if(sellTrendCount >= MaxTrendPositions && sellTrend_FirstPositionTime > 0)
      {
         sellTrend_TimeAttackActive = true;
         Print("=== 매도 추세: 최대 포지션 도달! 타임어택 시작 (", TimeAttackMinutes, "분) ===");
      }
   }
}

//+------------------------------------------------------------------+
//| 특정 매직넘버 모든 포지션 청산                                    |
//+------------------------------------------------------------------+
void CloseAllPositionsByMagic(int magicNumber)
{
   for(int i = PositionsTotal() - 1; i >= 0; i--)
   {
      ulong ticket = PositionGetTicket(i);
      if(ticket > 0)
      {
         if(PositionGetString(POSITION_SYMBOL) == _Symbol &&
            PositionGetInteger(POSITION_MAGIC) == magicNumber)
         {
            trade.PositionClose(ticket);
            PrintFormat("타임어택 청산: Ticket=%d Magic=%d", ticket, magicNumber);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| SL 이벤트 감지 및 쿨다운 활성화                                   |
//+------------------------------------------------------------------+
void CheckSLEvents()
{
   static int lastTotalDeals = 0;
   int totalDeals = 0;
   
   if(HistorySelect(0, TimeCurrent()))
   {
      totalDeals = HistoryDealsTotal();
      
      if(totalDeals > lastTotalDeals)
      {
         ulong ticket = HistoryDealGetTicket(totalDeals - 1);
         
         if(ticket > 0)
         {
            long dealMagic = HistoryDealGetInteger(ticket, DEAL_MAGIC);
            
            if(dealMagic == MagicNumber_BuyBasic || 
               dealMagic == MagicNumber_BuyTrend ||
               dealMagic == MagicNumber_SellBasic || 
               dealMagic == MagicNumber_SellTrend)
            {
               long dealEntry = HistoryDealGetInteger(ticket, DEAL_ENTRY);
               double dealProfit = HistoryDealGetDouble(ticket, DEAL_PROFIT);
               
               if(dealEntry == DEAL_ENTRY_OUT && dealProfit < 0)
               {
                  datetime currentTime = TimeCurrent();
                  
                  if(lastSLTime > 0 && (currentTime - lastSLTime) <= SL_CooldownMinutes * 60)
                  {
                     tradingBlocked = true;
                     blockUntilTime = currentTime + (SL_CooldownMinutes * 60);
                     Print("=== 경고: ", SL_CooldownMinutes, "분 내 SL 재발생! ===");
                     Print("거래 정지 활성화: ", SL_CooldownMinutes, "분간 모든 거래 중단");
                  }
                  
                  lastSLTime = currentTime;
                  
                  if(dealMagic == MagicNumber_BuyTrend)
                  {
                     if(buyTrend_LastSL > 0 && (currentTime - buyTrend_LastSL) <= 60 * 60)
                     {
                        buyTrend_SLCount++;
                        Print("매수 추세: SL 발생 #", buyTrend_SLCount);
                        
                        if(buyTrend_SLCount >= 2)
                        {
                           buyTrend_Blocked = true;
                           buyTrend_BlockUntil = currentTime + (TrendSL_BlockMinutes * 60);
                           Print("=== 매수 추세: SL 2회 → ", TrendSL_BlockMinutes, "분 정지 ===");
                           buyTrend_SLCount = 0;
                        }
                     }
                     else
                     {
                        buyTrend_SLCount = 1;
                     }
                     buyTrend_LastSL = currentTime;
                  }
                  else if(dealMagic == MagicNumber_SellTrend)
                  {
                     if(sellTrend_LastSL > 0 && (currentTime - sellTrend_LastSL) <= 60 * 60)
                     {
                        sellTrend_SLCount++;
                        Print("매도 추세: SL 발생 #", sellTrend_SLCount);
                        
                        if(sellTrend_SLCount >= 2)
                        {
                           sellTrend_Blocked = true;
                           sellTrend_BlockUntil = currentTime + (TrendSL_BlockMinutes * 60);
                           Print("=== 매도 추세: SL 2회 → ", TrendSL_BlockMinutes, "분 정지 ===");
                           sellTrend_SLCount = 0;
                        }
                     }
                     else
                     {
                        sellTrend_SLCount = 1;
                     }
                     sellTrend_LastSL = currentTime;
                  }
               }
            }
         }
      }
      
      lastTotalDeals = totalDeals;
   }
}

//+------------------------------------------------------------------+
//| 거래 정지 상태 업데이트                                           |
//+------------------------------------------------------------------+
void UpdateTradingBlockStatus()
{
   if(tradingBlocked)
   {
      datetime currentTime = TimeCurrent();
      
      if(currentTime >= blockUntilTime)
      {
         tradingBlocked = false;
         lastSLTime = 0;
         Print("=== 거래 정지 해제 ===");
      }
   }
}

//+------------------------------------------------------------------+
//| 추세 전략 정지 상태 업데이트                                      |
//+------------------------------------------------------------------+
void UpdateTrendBlockStatus()
{
   datetime currentTime = TimeCurrent();
   
   if(buyTrend_Blocked && currentTime >= buyTrend_BlockUntil)
   {
      buyTrend_Blocked = false;
      Print("=== 매수 추세: 정지 해제 ===");
   }
   
   if(sellTrend_Blocked && currentTime >= sellTrend_BlockUntil)
   {
      sellTrend_Blocked = false;
      Print("=== 매도 추세: 정지 해제 ===");
   }
}

//+------------------------------------------------------------------+
//| 매수 기본 전략                                                    |
//+------------------------------------------------------------------+
void CheckBuyBasicStrategy()
{
   double stoch_1 = stochMain[1];
   double stoch_2 = stochMain[2];
   double ma_1 = stochMA[1];
   double ma_2 = stochMA[2];
   double bb_1 = bbLower[1];
   double bbMid_1 = bbMiddle[1];
   double bbMid_2 = bbMiddle[2];
   
   if(buyBasic_ReadyToEnter)
   {
      datetime currentTime = TimeCurrent();
      int elapsedMinutes = (int)((currentTime - buyBasic_ReadyTime) / 60);
      
      if(elapsedMinutes >= BasicEntryWaitMinutes)
      {
         buyBasic_ReadyToEnter = false;
         buyBasic_ReadyTime = 0;
         Print("=== 매수 기본: 진입 대기 시간 초과 (취소) ===");
         return;
      }
      
      double close_1 = iClose(_Symbol, PERIOD_CURRENT, 1);
      double open_1 = iOpen(_Symbol, PERIOD_CURRENT, 1);
      
      if(close_1 < open_1)
      {
         Print("=== 매수 기본: 음봉 마감 확인 → 진입 ===");
         OpenPosition(POSITION_TYPE_BUY, MagicNumber_BuyBasic, "BuyBasic");
         
         buyBasic_Waiting = false;
         buyBasic_CrossCount = 0;
         buyBasic_Success1 = false;
         buyBasic_Success2 = false;
         buyBasic_ReadyToEnter = false;
         buyBasic_ReadyTime = 0;
      }
      
      return;
   }
   
   if(!buyBasic_Waiting)
   {
      if(stoch_1 < Level_Low && bb_1 < Level_Low)
      {
         buyBasic_Waiting = true;
         buyBasic_CrossCount = 0;
         buyBasic_Success1 = false;
         buyBasic_Success2 = false;
         Print("=== 매수 기본: 대기 진입 ===");
      }
   }
   
   if(buyBasic_Waiting && stoch_1 >= Level_BuyCancel)
   {
      buyBasic_Waiting = false;
      buyBasic_CrossCount = 0;
      buyBasic_Success1 = false;
      buyBasic_Success2 = false;
      Print("=== 매수 기본: 대기 해제 (40 이상) ===");
      return;
   }
   
   if(buyBasic_Waiting)
   {
      bool goldenCross = (stoch_2 <= ma_2) && (stoch_1 > ma_1);
      bool deathCross = (stoch_2 >= ma_2) && (stoch_1 < ma_1);
      
      if(buyBasic_CrossCount == 0 && goldenCross)
      {
         buyBasic_CrossCount = 1;
         Print("매수 기본: 단계1 골든크로스");
      }
      else if(buyBasic_CrossCount == 1 && deathCross)
      {
         buyBasic_CrossCount = 2;
         Print("매수 기본: 단계2 데드크로스");
      }
      else if(buyBasic_CrossCount == 2 && goldenCross)
      {
         buyBasic_CrossCount = 3;
         buyBasic_Success1 = true;
         Print("매수 기본: 단계3 골든크로스 → Success1 완성!");
      }
      
      bool stochCrossBBMid = (stoch_2 <= bbMid_2) && (stoch_1 > bbMid_1);
      if(stochCrossBBMid)
      {
         buyBasic_Success2 = true;
         Print("매수 기본: Stoch ↑ BB중심선 → Success2 완성!");
      }
      
      if(buyBasic_Success1 && buyBasic_Success2)
      {
         buyBasic_ReadyToEnter = true;
         buyBasic_ReadyTime = TimeCurrent();
         Print("=== 매수 기본: 신호 완성! 음봉 마감 대기 중... ===");
      }
   }
}

//+------------------------------------------------------------------+
//| 매수 추세 전략 (MA23 기반 + 포지션 제한)                          |
//+------------------------------------------------------------------+
void CheckBuyTrendStrategy()
{
   if(buyTrend_Blocked)
      return;
   
   if(!IsTrendTradingTime())
      return;
   
   // 포지션 수 체크
   int currentPositions = CountTrendPositions(MagicNumber_BuyTrend);
   if(currentPositions >= MaxTrendPositions)
      return;
   
   double ma23_1 = ma3Values[1];
   double ma69_1 = ma1Values[1];
   double ma60_1 = ma2Values[1];
   
   double close_1 = iClose(_Symbol, PERIOD_CURRENT, 1);
   double open_1 = iOpen(_Symbol, PERIOD_CURRENT, 1);
   double low_1 = iLow(_Symbol, PERIOD_CURRENT, 1);
   
   bool ma23Above = (ma23_1 > ma69_1) && (ma23_1 > ma60_1);
   
   if(!ma23Above)
   {
      buyTrend_BelowMA23 = false;
      return;
   }
   
   if(low_1 < ma23_1)
   {
      buyTrend_BelowMA23 = true;
   }
   
   bool bullishCandle = (close_1 > open_1);
   bool closeAboveMA23 = (close_1 > ma23_1);
   
   if(buyTrend_BelowMA23 && bullishCandle && closeAboveMA23)
   {
      Print("=== 매수 추세: 진입 (MA23 터치 후 양봉 종가 복귀) ===");
      OpenPosition(POSITION_TYPE_BUY, MagicNumber_BuyTrend, "BuyTrend");
      
      // 첫 포지션 진입 시간 기록
      if(currentPositions == 0)
      {
         buyTrend_FirstPositionTime = TimeCurrent();
         Print("매수 추세: 첫 포지션 진입 시간 기록");
      }
      
      buyTrend_BelowMA23 = false;
   }
}

//+------------------------------------------------------------------+
//| 매도 기본 전략                                                    |
//+------------------------------------------------------------------+
void CheckSellBasicStrategy()
{
   double stoch_1 = stochMain[1];
   double stoch_2 = stochMain[2];
   double ma_1 = stochMA[1];
   double ma_2 = stochMA[2];
   double bb_1 = bbUpper[1];
   double bbMid_1 = bbMiddle[1];
   double bbMid_2 = bbMiddle[2];
   
   if(sellBasic_ReadyToEnter)
   {
      datetime currentTime = TimeCurrent();
      int elapsedMinutes = (int)((currentTime - sellBasic_ReadyTime) / 60);
      
      if(elapsedMinutes >= BasicEntryWaitMinutes)
      {
         sellBasic_ReadyToEnter = false;
         sellBasic_ReadyTime = 0;
         Print("=== 매도 기본: 진입 대기 시간 초과 (취소) ===");
         return;
      }
      
      double close_1 = iClose(_Symbol, PERIOD_CURRENT, 1);
      double open_1 = iOpen(_Symbol, PERIOD_CURRENT, 1);
      
      if(close_1 > open_1)
      {
         Print("=== 매도 기본: 양봉 마감 확인 → 진입 ===");
         OpenPosition(POSITION_TYPE_SELL, MagicNumber_SellBasic, "SellBasic");
         
         sellBasic_Waiting = false;
         sellBasic_CrossCount = 0;
         sellBasic_Success1 = false;
         sellBasic_Success2 = false;
         sellBasic_ReadyToEnter = false;
         sellBasic_ReadyTime = 0;
      }
      
      return;
   }
   
   if(!sellBasic_Waiting)
   {
      if(stoch_1 > Level_High && bb_1 > Level_High)
      {
         sellBasic_Waiting = true;
         sellBasic_CrossCount = 0;
         sellBasic_Success1 = false;
         sellBasic_Success2 = false;
         Print("=== 매도 기본: 대기 진입 ===");
      }
   }
   
   if(sellBasic_Waiting && stoch_1 <= Level_SellCancel)
   {
      sellBasic_Waiting = false;
      sellBasic_CrossCount = 0;
      sellBasic_Success1 = false;
      sellBasic_Success2 = false;
      Print("=== 매도 기본: 대기 해제 (60 이하) ===");
      return;
   }
   
   if(sellBasic_Waiting)
   {
      bool goldenCross = (stoch_2 <= ma_2) && (stoch_1 > ma_1);
      bool deathCross = (stoch_2 >= ma_2) && (stoch_1 < ma_1);
      
      if(sellBasic_CrossCount == 0 && deathCross)
      {
         sellBasic_CrossCount = 1;
         Print("매도 기본: 단계1 데드크로스");
      }
      else if(sellBasic_CrossCount == 1 && goldenCross)
      {
         sellBasic_CrossCount = 2;
         Print("매도 기본: 단계2 골든크로스");
      }
      else if(sellBasic_CrossCount == 2 && deathCross)
      {
         sellBasic_CrossCount = 3;
         sellBasic_Success1 = true;
         Print("매도 기본: 단계3 데드크로스 → Success1 완성!");
      }
      
      bool stochCrossBBMid = (stoch_2 >= bbMid_2) && (stoch_1 < bbMid_1);
      if(stochCrossBBMid)
      {
         sellBasic_Success2 = true;
         Print("매도 기본: Stoch ↓ BB중심선 → Success2 완성!");
      }
      
      if(sellBasic_Success1 && sellBasic_Success2)
      {
         sellBasic_ReadyToEnter = true;
         sellBasic_ReadyTime = TimeCurrent();
         Print("=== 매도 기본: 신호 완성! 양봉 마감 대기 중... ===");
      }
   }
}

//+------------------------------------------------------------------+
//| 매도 추세 전략 (MA23 기반 + 포지션 제한)                          |
//+------------------------------------------------------------------+
void CheckSellTrendStrategy()
{
   if(sellTrend_Blocked)
      return;
   
   if(!IsTrendTradingTime())
      return;
   
   // 포지션 수 체크
   int currentPositions = CountTrendPositions(MagicNumber_SellTrend);
   if(currentPositions >= MaxTrendPositions)
      return;
   
   double ma23_1 = ma3Values[1];
   double ma69_1 = ma1Values[1];
   double ma60_1 = ma2Values[1];
   
   double close_1 = iClose(_Symbol, PERIOD_CURRENT, 1);
   double open_1 = iOpen(_Symbol, PERIOD_CURRENT, 1);
   double high_1 = iHigh(_Symbol, PERIOD_CURRENT, 1);
   
   bool ma23Below = (ma23_1 < ma69_1) && (ma23_1 < ma60_1);
   
   if(!ma23Below)
   {
      sellTrend_AboveMA23 = false;
      return;
   }
   
   if(high_1 > ma23_1)
   {
      sellTrend_AboveMA23 = true;
   }
   
   bool bearishCandle = (close_1 < open_1);
   bool closeBelowMA23 = (close_1 < ma23_1);
   
   if(sellTrend_AboveMA23 && bearishCandle && closeBelowMA23)
   {
      Print("=== 매도 추세: 진입 (MA23 터치 후 음봉 종가 복귀) ===");
      OpenPosition(POSITION_TYPE_SELL, MagicNumber_SellTrend, "SellTrend");
      
      // 첫 포지션 진입 시간 기록
      if(currentPositions == 0)
      {
         sellTrend_FirstPositionTime = TimeCurrent();
         Print("매도 추세: 첫 포지션 진입 시간 기록");
      }
      
      sellTrend_AboveMA23 = false;
   }
}

//+------------------------------------------------------------------+
//| 포지션 열기 (양방향 가능)                                          |
//+------------------------------------------------------------------+
void OpenPosition(ENUM_POSITION_TYPE type, int magic, string comment)
{
   trade.SetExpertMagicNumber(magic);

   double lot = LotSize;
   double price = 0.0;
   double sl = 0.0, tp = 0.0;

   double point  = SymbolInfoDouble(_Symbol, SYMBOL_POINT);
   int digits    = (int)SymbolInfoInteger(_Symbol, SYMBOL_DIGITS);
   long stopLevel = (long)SymbolInfoInteger(_Symbol, SYMBOL_TRADE_STOPS_LEVEL);

   if(UseSLTP && StopLoss > 0)
   {
      long adjStop = MathMax((long)StopLoss, stopLevel);
      long adjTP   = (TakeProfit > 0) ? MathMax((long)TakeProfit, stopLevel) : 0;

      if(type == POSITION_TYPE_BUY)
      {
         double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
         sl = NormalizeDouble( ask - adjStop * point, digits );
         if(adjTP > 0) tp = NormalizeDouble( ask + adjTP * point, digits );
      }
      else
      {
         double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
         sl = NormalizeDouble( bid + adjStop * point, digits );
         if(adjTP > 0) tp = NormalizeDouble( bid - adjTP * point, digits );
      }
   }

   bool result = false;
   if(type == POSITION_TYPE_BUY)
   {
      result = trade.Buy(lot, _Symbol, price, sl, tp, comment);
      if(result)
         PrintFormat("매수 성공: %s lot=%.2f sl=%.5f tp=%.5f", comment, lot, sl, tp);
      else
         PrintFormat("매수 실패: %s rc=%d desc=%s", comment, trade.ResultRetcode(), trade.ResultRetcodeDescription());
   }
   else if(type == POSITION_TYPE_SELL)
   {
      result = trade.Sell(lot, _Symbol, price, sl, tp, comment);
      if(result)
         PrintFormat("매도 성공: %s lot=%.2f sl=%.5f tp=%.5f", comment, lot, sl, tp);
      else
         PrintFormat("매도 실패: %s rc=%d desc=%s", comment, trade.ResultRetcode(), trade.ResultRetcodeDescription());
   }
}
//+------------------------------------------------------------------+